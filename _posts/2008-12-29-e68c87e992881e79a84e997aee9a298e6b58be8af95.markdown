---
author: amosk
comments: true
date: 2008-12-29 01:36:15+00:00
layout: post
slug: '%e6%8c%87%e9%92%881%e7%9a%84%e9%97%ae%e9%a2%98%e6%b5%8b%e8%af%95'
title: 指针+1的问题测试
wordpress_id: 311
categories:
- Web
---

测试程序：

    
    #include
    #include
    
    struct t {
    	char p[10];
    	char p2[10];
    }t1,t2;
    int main(void)
    {
    	struct t * q=&t1;
    	struct t * p=&t2;
    	printf("栈顶	\n...\n高地址 q-------\n\tABCD\n\tEFGH\n低地址 p-------\n\tabcd\n\tefgh\n\n");
    
    	strcpy(q->p,"ABCD");
    	strcpy(p->p,"abcd");
    	strcpy(q->p2,"EFGH");
    	strcpy(p->p2,"efgh");
    
    	printf("(char *)p:\t%s\n(char *)(p+1):\t%s\n", (char *)p,(char *)(p+1));
    	//这里第二个参数打印ABCD，正好跳过一个结构体
    	printf("(char *)(q-1):\t%s\n",(char *)(q-1));
    	printf("(char *)q:\t%s\n(char *)q+1:\t%s\n", (char *)q,(char *)q+1);
    	//这里第二个参数打印BCD，说明跳过了一字节
    
    	printf("sizeof(struct t):%d\n",sizeof(struct t));
    	printf("q:\t%p\nq+1:\t%p\n",q,q+1);
    	//这两个结果为0x14，正好是十进制的20,即结构体的大小
    
    	return 0;
    }



    
    kongove@ubuntu:~$ ./a.out
    栈顶
    ...
    高地址 q-------
    	ABCD	//(p+1)指向A所在地址 (char*)q+1指向B所在地址
    	EFGH
    低地址 p-------
    	abcd	//(q-1)指向a所在地址
    	efgh
    
    (char *)p:		abcd
    (char *)(p+1):	ABCD
    (char *)(q-1):	abcd
    (char *)q:		ABCD
    (char *)q+1:	BCD
    sizeof(struct t):20
    q:	0x804a038
    q+1:	0x804a04c



p,q都为(struct task_struct *)类型的
p+1指向的地址为p+sizeof(struct task_struct)
(char *)p+1指向的地址为p+sizeof(char)即p的下一字节

在(char *)(p+1)中，(char *)只是告诉编译器从这个地址起，读取数据直到遇到’′,并不影响取址。

总结：p为指针，则p+1指向的地址为p+sizeof(p原来的类型/p被转化成的类型)。
