---
author: amosk
comments: true
date: 2007-10-17 15:21:33+00:00
layout: post
slug: '123'
title: 上机的另一个程序
wordpress_id: 123
categories:
- Linux
- Web
---

#include <stdio.h>
    #include <stdlib.h>
    #include <sys/wait.h>
    #include <unistd.h>
    #include <signal.h>
    /* 允许建立的子进程个数最大值 */
    #define MAX_CHILD_NUMBER 10
    /* 子进程睡眠时间 */
    #define SLEEP_INTERVAL 2
    int proc_number=0; /* 子进程的自编号，从0开始 */
    void do_something();
    main(int argc, char* argv[])<!-- more -->
    {
            int child_proc_number = MAX_CHILD_NUMBER; /* 子进程个数 */
            int i, ch;
            pid_t child_pid,p;
            pid_t pid[10]={0}; /* 存放每个子进程的id */
            if (argc > 1)
            {
            /* 命令行参数中的第一个参数表示建立几个子进程，最多10个 */
                    child_proc_number = atoi(argv[1]);
                    child_proc_number= (child_proc_number > 10) ? 10 : child_proc_number;
            }
            for (i=0; i<child_proc_number; i++)
            {
                    /* 在这里填写代码，建立child_proc_number个子进程
                    * 子进程要执行
                    * proc_number = i;
                    * do_something(); */
                    p=fork();
                    if(p==-1)
                    {
                            perror("Failed to fork!n");
                            exit(0);
                    }
                    else    if(p==0)
                            {
                                    proc_number=i;
                                    do_something();
                                    break;
                            }
                    pid[i]=p;
            }
            /* 父进程把子进程的id保存到pid[i] */
            /* 让用户选择杀死哪个进程。输入数字(自编号)表示杀死该进程
                    * 输入q退出 */
            while ((ch = getchar()) != 'q')
            {
                    if (isdigit(ch))
                    {
                            /* 在这里填写代码，向pid[ch-'0']发信号SIGTERM，
                            * 杀死该子进程 */
                            kill (pid[ch-'0'],SIGABRT);
                    }
            }
            /* 在这里填写代码，杀死本组的所有进程 */
            for(i=0;i<child_proc_number;i++);
            {
                    kill (pid[i],SIGABRT);
            }
            return 0;
    }
    void do_something()
    {
    /* 打印子进程自编号。为清晰，在每个号码前加“号码+3”个空格
    * 比如号码是1，就打印" 1" */
            printf("This is process No.%*dn",proc_number+3,proc_number);
            sleep(2); /* 主动阻塞两秒钟 */
    }
    /*先猜想一下这个程序的运行结果。假如运行“./process 20”，输出会是什么
    样？
    
    然后按照注释里的要求把代码补充完整，运行程序。可以多运行一会儿，并在
    此期间启动、关闭一些其它进程，看process 的输出结果有什么特点，记录下这个结果。
    
    开另一个终端窗口，运行“ps aux|grep process”命令，看看process 究
    竟启动了多少个进程。
    
    回到程序执行窗口，按“数字键+回车”尝试杀掉一两个进程，再到另一个窗口
    看进程状况。
    
    按q 退出程序再看进程情况。
    
    2.4 实验报告
    回答下列问题，写入实验报告。
    
    1. 你最初认为运行结果会怎么样？
    2. 实际的结果什么样？有什么特点？试对产生该现象的原因进行分析。
    3. proc_number 这个全局变量在各个子进程里的值相同吗？为什么？
    4. kill 命令在程序中使用了几次？每次的作用是什么？执行后的现象是什么？
    5. 使用kill 命令可以在进程的外部杀死进程。进程怎样能主动退出？这两种退
    出方式哪种更好一些？*/
