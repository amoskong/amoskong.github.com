---
author: amosk
comments: true
date: 2007-12-16 11:53:56+00:00
layout: post
slug: '%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e7%a8%8b%e5%ba%8f'
title: 内存分配程序
wordpress_id: 163
categories:
- Web
---

这是一个内存分配的实验题目         （再次更新于11.23 5：33，感谢牛涛同学的指错，欢迎大家在提意见，以改进程序！）
    #include
    #include
    #include              /*if you compize in linux system,you need this line*/
    /*#include */
    
    #define MIN_SLICE 10         /*default size of slice*/
    #define DEFAULT_MEM_SIZE 1024   /*default size of memory*/
    #define DEFAULT_MEM_START 0     /*default start address of memory*/
    
    /* the method of manager memory*/
    #define MA_FF 1
    #define MA_BF 2
    #define MA_WF 3
    
    int mem_size = DEFAULT_MEM_SIZE;          /*size of memory*/
    int ma_algorithm = MA_FF;               /*the working method*/
    static int pid = 0;                     /*default pid*/
    int flag;
    int start_addr = DEFAULT_MEM_START;
    struct free_block_type{
            int start_addr;
            int size;
            struct free_block_type *next;
    }*free_block;
    
    struct allocated_block{
            int pid;
            int size;
            int start_addr;
            char process_name[12];
            struct allocated_block *next;
    };
    
    struct allocated_block *allocated_block_head = NULL;
    
    struct free_block_type* init_free_block(int mem_size){
            struct free_block_type *fb;
            fb = (struct free_block_type *)malloc(sizeof(struct free_block_type));
            if (fb == NULL){
                    printf("No mem\n");
                    return NULL;
            }
            fb->size = mem_size;
            fb->start_addr = DEFAULT_MEM_START;
            fb->next = NULL;
            return fb;
    }
    
    int set_mem_size(){
            int size;
            printf("Total memory size =");
            scanf("%d", &size);
            if (size > 0) {
                    free_block->size = size;
            }
            return 1;
    }
    
    void swap(struct free_block_type *p,struct free_block_type *temp)
    {
            int n;
            n = p->size;
            p->size = temp->size;
            temp->size = n;
            n = p->start_addr;
            p->start_addr = temp->start_addr;
            temp->start_addr = n;
    }
    
    void rearrange_FF()
    {
            struct free_block_type *p,*temp;
            printf("Rearrange free blocks for FF \n");
            p = free_block;
            while (p->next != NULL)
            {
                    temp = p->next;
                    while (temp != NULL)
                    {
                            if (p->start_addr > temp->start_addr)
                                    swap(p,temp);
                            temp = temp->next;
                    }
                    p = p->next;
            }
    }
    
    void rearrange_BF(){
            struct free_block_type *p,*temp;
            printf("Rearrange free blocks for BF \n");
            p = free_block;
            while (p->next != NULL)
            {
                    temp = p->next;
                    while (temp != NULL)
                    {
                            if (p->size > temp->size)
                                    swap(p, temp);
                            temp = temp->next;
                    }
                    p = p->next;
            }
    }
    
    void rearrange_WF(){
            struct free_block_type *p,*temp;
            printf("Rearrange free blocks for WF \n");
            p = free_block;
            while (p->next != NULL)
            {
                    temp = p->next;
                    while (temp != NULL)
                    {
                            if (p->size size)
                                    swap(p,temp);
                            temp = temp->next;
                    }
                    p = p->next;
            }
    }
    
    void rearrange(int algorithm){
            switch(algorithm){
                    case 1: rearrange_FF(); break;
                    case 2: rearrange_BF(); break;
                    case 3: rearrange_WF(); break;
            }
    }
    
    void do_exit(){
            printf("Exit this programme!\n");
    }
    
    struct allocated_block *find_process(int pid){
            struct allocated_block *ab;
            ab = allocated_block_head;
            while (ab->pid != pid&&ab->next != NULL) ab = ab->next;
            if (ab->pid != pid){
                    printf("Not process:%d\n", pid);
                    return NULL;
            }
            else
                    return ab;
    
    }
    
    void display_menu(int i){
            printf(" ---------------------------------------------------------------\n");
            printf("|       1 : Set the size of memory                              |\n");
            printf("|       2 : Set the method of management                        |\n");
            printf("|       3 : Creat new process                                   |\n");
            printf("|       4 : Delete process                                      |\n");
            printf("|       5 : Display the status of memory                        |\n");
            printf("|       0 : Quit the programme                                  |\n");
            printf(" -----------------------Commands : %4d -------------------------\n",i);
    }
    
    void set_algorithm(){
            int algorithm;
            printf("\t1 - First Fit\n");
            printf("\t2 - Best Fit \n");
            printf("\t3 - Worst Fit \n");
            scanf("%d", &algorithm);
            if (algorithm >= 1 && algorithm size;
            ab2 = ab;
            fbt = pre = free_block;
            while (fbt != NULL){
    
                    if (fbt->size >= request_size){
                            if (fbt->size start_addr = fbt->start_addr;
                                    ab->size = fbt->size;
                                    /*ab->next=fbt->next;
                                    printf("ab_start_ad:%d  fbt:%d\n",ab->start_addr, fbt->start_addr);*/
                                    if (fbt == free_block)
                                            free_block = fbt->next;
                                    else {
                                            while (pre->next != fbt) pre = pre->next;
                                            pre->next = fbt->next;
                                    }
                            }
                            else {
                                    fbt->size -= request_size;
                                    ab = (struct allocated_block *) malloc(sizeof(struct allocated_block));
                                    ab->start_addr = fbt->start_addr;
                                    ab->size -= fbt->size;
                                    fbt->start_addr += request_size;
                            }
                            start_addr = ab->start_addr;
                            return 1;
                    }
                    else {
                            pre = fbt;
                            fbt = fbt->next;
                    }
            }
            return -1;
    }
    
    int new_process(){
            struct allocated_block *ab;
            int size;
            int ret;
            ab = (struct allocated_block *)malloc(sizeof(struct allocated_block));
            if (!ab) exit(-5);
            ab->next = NULL;
            pid++;
            sprintf(ab->process_name, "PROCESS-%02d", pid);
            ab->pid = pid;
    
            printf("Memory for %s:", ab->process_name);
            scanf("%d", &size);
            if (size > 0) ab->size = size;
            ret = allocate_mem(ab);
            ab->start_addr = start_addr;
            if ((ret == 1) && (allocated_block_head == NULL)){
                    allocated_block_head = ab;
                    ab->start_addr = start_addr;
                    start_addr += ab->size;
                    return 1;
            }
            else if (ret == 1) {
                    ab->next = allocated_block_head;
                    allocated_block_head = ab;
                    return 2;
            }
            else if (ret == -1){
                    printf("Allocation fail\n");
                    free(ab);
                    return -1;
            }
            return 3;
    }
    
    int free_mem(struct allocated_block *ab){
            int algorithm = ma_algorithm;
            struct free_block_type *fbt, *work;
            fbt = (struct free_block_type *) malloc(sizeof(struct free_block_type));
            if (fbt == NULL){
                    printf("Fail malloc!\n");
                    return (int)NULL;
            }
            fbt->size = ab->size;
            fbt->start_addr = ab->start_addr;
            fbt->next = free_block;
            free_block = fbt;
            rearrange(MA_FF);
            fbt = free_block;
            /*sort the memory*/
            while (fbt != NULL){
                    work = fbt->next;
                    if (work != NULL){
                            if (work->start_addr == fbt->size+fbt->start_addr){
                                    fbt->size = fbt->size+fbt->next->size;
                                    fbt->next = fbt->next->next;
                                    continue;
                            }
                    }
                    fbt = fbt->next;
            }
            rearrange(algorithm);/*sort the memory again */
            return 1;
    }
    
    int dispose(struct allocated_block *free_ab){
            struct allocated_block *pre, *ab;
    
            if (free_ab == allocated_block_head) {
                    allocated_block_head = allocated_block_head->next;
                    free(free_ab);
                    return 1;
            }
    
            pre = allocated_block_head;
            ab = allocated_block_head->next;
    
            while (ab != free_ab){ pre = ab;  ab = ab->next; }
            pre->next = ab->next;
            free(ab);
            return 2;
    }
    
    void kill_process(){
            struct allocated_block *ab;
            int pid;
            printf("Kill Process, pid =");
            scanf("%d", &pid);
            ab = find_process(pid);
    
            if (ab != NULL){
                    free_mem(ab);
                    dispose(ab);
            }
    }
    
    int display_mem_usage(){
            struct free_block_type *fbt=free_block;
            struct allocated_block *ab=allocated_block_head;
            if (fbt == NULL) return(-1);
            printf("----------------------------------------------------------\n");
            printf("Free Memory:\n");
            printf("%26s %20s\n", "      start_addr", "       size");
            while (fbt != NULL){
                    printf("%26d %20d\n", fbt->start_addr, fbt->size);
                    fbt = fbt->next;
            }
            printf("\nUsed Memory:\n");
            printf("%10s %15s %10s\n", "PID", "start_addr", " size");
            while (ab != NULL){
                    printf("%10d %15d %10d\n", ab->pid, ab->start_addr, ab->size);
                    ab = ab->next;
            }
            printf("----------------------------------------------------------\n");
            return 0;
    }
    
    int main(void){
            char choice[10];
            int i;
            printf("                The Programme Of Manager Memory\n\n\n");
            printf("                                Made by Jianjun Kong\n\n");
            pid=0;
            free_block = init_free_block(mem_size); /*init the free block*/
            for (i = 1; ; i++){
                    display_menu(i);
                    fflush(stdin);
                    printf("command>");
                    scanf("%s", choice);
                    switch(choice[0]){
                            case '1':set_mem_size(); break;                /*Set the size of memory*/
                            case '2': set_algorithm(); flag=1; break;      /*Set the method of management*/
                            case '3': new_process(); flag=1; break;        /*Creat new process*/
                            case '4': kill_process(); flag=1; break;       /*Delete process*/
                            case '5': display_mem_usage(); flag=1; break;  /*Display the status of memory*/
                            case '0':                                      /*Quit the programme*/
                            case 'q': do_exit(); exit(0); break;           /*Quit the programme*/
                            default : printf("Wrong usage!\n"); break;     /*Wrong usage*/
                    }
            }
    }
