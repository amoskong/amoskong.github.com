<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="http://www.zeuux.org/style/zeuux.cn.css" title="ZEUUX Project style">
<title>学习tcpdump－文档－哲思自由软件社区</title>
</head>

<body>
<script src="/js/header.cn.js" language="javascript" type="text/javascript"></script>

<div class="main">
  <div class="big_content">
	<h1>学习tcpdump</h1>
	<h2>作者：<a href="mailto:jianjun@zeuux.org">孔建军</a></h2>

	<h3>tcpdump介绍</h3>
	<p>
	  tcpdump 是一款开源的网络数据截取分析工具，具有强大的功能和灵活的截取策略，用在网络的分析、维护、统计、检测等方面，例如定位网络瓶颈、统计网络流量使用情况等。它支持针对网络层、协议、主机、网络或端口的过滤，正则表达式的灵活应用能帮你准确获取有用信息。<br>
	  tcpdump 具备开源软件的优势，接口公开，具有较强的可扩展性。运行此命令必须有root权限，它通过将网络接口设置为混杂模式，绕过标准TCP/IP堆栈，进行工作。出于安全等问题考虑，FreeBSD里通过内核取消对伪设备bpfilter的支持，来屏蔽tcpdump之类的网络分析工具，也可使用网桥、交换机等将不信任网络隔开，但不能解决内网通信安全问题。在linux下可采用软件包或编译源代码的方式安装。<br>
	  tcpdump官方网站：<a href="http://www.tcpdump.org/">http://www.tcpdump.org/</a></p>

	<h3>运行效果</h3>
	<div class="code_outline">
	<pre class="display_code">
	kongove@ubuntu:~$ sudo tcpdump  -i eth0 host ubuntu.local
	tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
	listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
	09:39:10.448284 IP ubuntu.local.2425 > 255.255.255.255.2425: UDP, length 35
	09:39:15.565249 IP ubuntu.local.2425 > 255.255.255.255.2425: UDP, length 29
	</pre></div>

	<h3>基本使用</h3>
	<div class="code_outline">
	<pre class="display_code">
	  tcpdump [ -AdDeflLnNOpqRStuUvxX ] [ -c count ] [ -C file_size ] [ -F file ]
	  [ -i interface ] [ -m module ] [ -M secret ][ -r file ] [ -s snaplen ]
	  [ -T type ] [ -w file ] [ -W filecount ][ -E spi@ipaddr algo:secret,...  ]
	  [ -y datalinktype ] [ -Z user ] [ expression ]
	</pre></div>
<p>通过对 tcpdump 选项、参数、表达式的组合应用，从大流量的网络数据当中，过滤出真正有用的信息，从而缩小分析范围。</p>
	<h4>tcpdump选项</h4>
	<table border="0" cellpadding="0" cellspacing="1" class="tab1">
	  <tr>
		<th>选项</th>
		<th>含义</th>
	  </tr>
	  <tr>
		<td>-A</td>
		<td>以ASCII格式打印出所有分组，并将链路层的头最小化</td>
	  </tr>
	  <tr>
		<td>-d</td>
		<td>将匹配信息包的代码以人们能够理解的汇编格式给出</td>
	  </tr>
	  <tr>
		<td>-D</td>
		<td>打印出系统中所有可以用tcpdump截包的网络接口</td>
	  </tr>
	  <tr>
		<td>-ddd</td>
		<td>将匹配信息包的代码以十进制的形式输出</td>
	  </tr>
	  <tr>
		<td>-e</td>
		<td>在输出行打印出数据链路层的头部信息</td>
	  </tr>
	  <tr>
		<td>-f</td>
		<td>将外部的Internet地址以数字的形式打印出来</td>
	  </tr>
	  <tr>
		<td>-l</td>
		<td>使标准输出变为缓冲行形式</td>
	  </tr>
	  <tr>
		<td>-L</td>
		<td>列出网络接口的已知数据链路</td>
	  </tr>
	  <tr>
		<td>-n</td>
		<td>不把网络地址转换成名字</td>
	  </tr>
	  <tr>
		<td>-N</td>
		<td>不输出主机名中的域名部分，如“kongove.ubuntu.cn”只输出“kongove”</td>
	  </tr>
	  <tr>
		<td>-O</td>
		<td>不运行分组分组匹配（packet-matching）代码优化程序</td>
	  </tr>
	  <tr>
		<td>-p</td>
		<td>不将网络接口设置成混杂模式</td>
	  </tr>
	  <tr>
		<td>-q</td>
		<td>快速输出，只输出较少的协议信息</td>
	  </tr>
	  <tr>
		<td>-S</td>
		<td>将tcp的序列号以绝对值形式输出，而不是相对值</td>
	  </tr>
	  <tr>
		<td>-t</td>
		<td>在输出的每一行不打印时间戳</td>
	  </tr>
	  <tr>
		<td>-u</td>
		<td>输出未解码的NFS句柄</td>
	  </tr>
	  <tr>
		<td>-v</td>
		<td>输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息</td>
	  </tr>
	  <tr>
		<td>-vv</td>
		<td>输出详细的报文信息</td>
	  </tr>
	  <tr>
		<td>-c count</td>
		<td>指定监听数据包数量，当收到指定的包的数目后，tcpdump就会停止</td>
	  </tr>
	  <tr>
		<td>-C file_size</td>
		<td>限定数据包写入文件大小</td>
	  </tr>
	  <tr>
		<td>-F file</td>
		<td>从指定的文件中读取表达式,忽略其它的表达式</td>
	  </tr>
	  <tr>
		<td>-i interface</td>
		<td>指定监听网络接口</td>
	  </tr>
	  <tr>
		<td>-m module</td>
		<td>打开指定的SMI MIB组件</td>
	  </tr>
	  <tr>
		<td>-M secret</td>
		<td>如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详见RFC 2385）</td>
	  </tr>
	  <tr>
		<td>-r file</td>
		<td>从指定的文件中读取包(这些包一般通过-w选项产生)</td>
	  </tr>
	  <tr>
		<td>-s snaplen</td>
		<td>从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节</td>
	  </tr>
	  <tr>
		<td>-T type</td>
		<td>将截取的数据包直接解释为指定类型的报文，常见类型有rpc（远程过程调用）和snmp（简单网络管理协议），还包括aodv、cnfp、rpc、rtp、rtcp、snmp、tftp、vat、wb等</td>
	  </tr>
	  <tr>
		<td>-w file</td>
		<td>指定将监听到的数据包写入文件，不分析和打印数据包</td>
	  </tr>
	  <tr>
		<td>-W filecount</td>
		<td>限定能写入文件数据包的数量</td>
	  </tr>
	  <tr>
		<td>-E spi@ipaddr algo:secret,...</td>
		<td>用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组</td>
	  </tr>
	  <tr>
		<td>expression</td>
		<td>综合表达式</td>
	  </tr>
	</table>
	
	<h4>tcpdump的表达式介绍</h4>
	<p>
	  tcpdump利用正则表达式作为过滤报文的条件，如果数据包满足表达式的条件，则会被捕获。如果没有给出任何条件，则网络上所有的数据包将会被截获。表达式中常用关键字如下：<br>
	<ul>
	  <li>1) 指定参数类型的关键字，主要包括host，net，port等，如果没有指定类型，缺省的类型是host；</li>
	  例如：#tcpdump host 222.24.20.86 截获ip为222.24.20.86的主机收发的所有数据包<br>
	  <li>2) 指定数据报文传输方向的关键字，主要包括src , dst ,dst or src, dst and src，缺省为src or dst；</li>
	  例如：#tcpdump src net 222.24.20.1 截取源网络地址为 222.24.20.1 的所有数据包<br>
	  <li>3) 指定协议的关键字，主要包括fddi，ip，arp，rarp，tcp，udp等类型，默认监听所有协议的数据包；</li>
	  例如：#tucpdump arp 截获所有arp协议的数据包<br>
	  <li>4) 其他重要的关键字还有，gateway，broadcast，less，greater，三种逻辑运算（取非运算是 'not ','! '； 与运算是 'and ','&amp;&amp; '；或运算 是'or ','|| '）等。这些关键字的巧妙组合，能灵活构造过滤条件，从而满足用户需要。</li>
	  例如：#tcpdump host ubuntu and src port \(80 or 8080\) 截取主机ubuntu上源端口为80或8080的所有数据包。<br>
	</ul></p>
	<p>
	  expression一个或多个原语 (primitive)组成。原语通常由一个标识(id,名称或数字),和标识前面的一个或多个修饰子(qualifier)组成。 修饰子 有三种不同的类型:</p>
	<ul>
	  <li>type</li>
	  <p>
	    类型修饰子指出标识名称或标识数字代表什么类型的东西. 可以使用的类型有host, net 和 port。例如, `host foo', `net 128.3', `port 20'. 如果不指定类型修饰子, 就使用缺省的 host。</p>
	  <li>dir</li>
	  <p>
	    方向修饰子指出相对于标识的传输方向(数据是传入还是传出标识)。 可以使用的方向有 src, dst, src or dst 和 src and dst。例如, `src foo', `dst net 128.3', `src or dst port ftp-data'。如果不指定方向修饰子, 就使用缺省的src or dst。 对于`null'链路层 (就是说象slip之类的点到点协议), 用inbound和outbound修饰子指定所需的传输方向。</p>
	  
	  <li>proto</li>
	  <p>
	    协议修饰子要求匹配指定的协议。可以使用的协议有: ether, fddi, ip, arp, rarp, decnet, lat, sca, moprc, mopdl, tcp 和 udp。例如, `ether srcfoo', `arp net 128.3', `tcp port 21'。 如果不指定协议修饰子, 就使用所有符合类型的协议. 例如, `src foo' 指 `(ip 或 arp 或 rarp) src foo'(注意后者不符合语法), `net bar'指`(ip 或 arp 或 rarp) net bar', `port 53'指 `(tcp 或 udp) port 53'。（`fddi'实际上是 `ether'的别名; 分析器把它们视为 ``用在指定网络接口上的数据链路层.'' FDDI报头包含类似于以太协议的源目地址, 而且通常包含类似于以太协议的报文类型, 因此你可以过滤FDDI域, 就象分析以太协议一样. FDDI报头也包含其他域, 但是你不能在过滤器表达式里显式描述。）</p>
	</ul>
	<p>
	  作为上述的补充, 有一些特殊的`原语'关键字, 它们不同于上面的模式: gateway, broadcast, less, greater和数学表达式. 这些在后面有叙述。 更复杂的过滤器表达式 可以通过and, or和not连接原语来组建。 例如,`host foo and notport ftp and not port ftp-data'。为了少敲点键, 可以忽略相同的修饰子。 例如, `tcp dst port ftp or ftp-data or domain'实际上就是`tcp dst port ftp or tcp dst port ftp-data or tcp dst port domain'。</p>

	允许的 原语 有: 
	<ul>
	  <li>dst host host</li>
	  <p>
	    如果报文中IP的目的地址域是host, 则逻辑为真. host既可以是地址, 也可以是主机名.</p>
	  <li>src host host</li>
	  <p>
	    如果报文中IP的源地址域是host, 则逻辑为真.</p>
	  <li>host host</li>
	  <p>
	    如果报文中IP的源地址域或者目的地址域是host, 则逻辑为真. 上面所有的host表达式都可以加上ip, arp, 或rarp关键字做前缀, 就象:ip host host 它等价于: ether proto \ip and host host。</p>
	  <p>
	    如果host是拥有多个IP地址的主机名, 它的每个地址都会被查验。</p>

	  <li>ether dst ehost</li>
	  <p>
	    如果报文的以太目的地址是ehost, 则逻辑为真。Ehost既可以是名字(/etc/ethers里有),也可以是数字(有关数字格式另见 ethers(3N) )。</p>

	  <li>ether src ehost</li>
  	  <p>
	    如果报文的以太源地址是ehost, 则逻辑为真。</p>

	  <li>ether host ehost</li>
	  <p>
	    如果报文的以太源地址或以太目的地址是ehost, 则逻辑为真。</p>
	  <li>gateway host</li>
	  <p>
	    如果报文把host当做网关, 则逻辑为真。也就是说,报文的以太源或目的地址是host, 但是IP的源目地址都不是host。 host必须是个主机名, 而且必须存在/etc/hosts和/etc/ethers中. (一个等价的表达式是ether host ehost and not host host，对于 host/ehost, 它既可以是名字, 也可以是数字。)</p>
	  <li>dst net net</li>
	  <p>
	    如果报文的IP目的地址属于网络号net,则逻辑为真.net既可以是名字(存在/etc/networks中),也可以是网络号.(详见networks(4))。</p>
	  <li>src net net</li>
	  <p>
	    如果报文的IP源地址属于网络号net,则逻辑为真。</p>
	  <li>net net</li>
	  <p>
	    如果报文的IP源地址或目的地址属于网络号net,则逻辑为真.</p>
	  <li>net net mask mask</li>
	  <p>
	    如果IP地址匹配指定网络掩码(netmask)的net,则逻辑为真.本原语可以用src或dst修饰.</p>
	  <li>net net/len</li>
	  <p>
	    如果IP地址匹配指定网络掩码的net,则逻辑为真,掩码的有效位宽为len.本原语可以用src或dst修饰。</p>
	  <li>dst port port</li>
	  <p>
	    如果报文是ip/tcp或ip/udp,并且目的端口是port,则逻辑为真.port是一个数字,也可以是/etc/services中说明过的名字(参看tcp(4P)和udp(4P)).如果使用名字,则检查端口号和协议.如果使用数字,或者有二义的名字,则只检查端口号(例如,dstport513将显示tcp/login的数据和udp/who的数据,而portdomain将显示tcp/domain和udp/domain的数据)。</p>
	  <li>src port port</li>
	  <p>
	    如果报文的源端口号是port,则逻辑为真。</p>
	  <li>port port</li>
	  <p>
	    如果报文的源端口或目的端口是port,则逻辑为真.上述的任意一个端口表达式都可以用关键字tcp或udp做前缀,就象:</p>
	  <li>tcp src port port</li>
	  <p>
	    它只匹配源端口是port的TCP报文。</p>
	  <li>less length</li>
	  <p>
	    如果报文的长度小于等于length,则逻辑为真.它等同于:len <= length。</p>
	  <li>greater length </li>
	  <p>
	    如果报文的长度大于等于length,则逻辑为真.它等同于:len >= length。</p>

	<li>ip proto protocol </li>
	<p>
	  如果报文是IP数据报(参见ip(4P)),其内容的协议类型是protocol,则逻辑为真.Protocol可以是数字,也可以是下列名称中的一个:icmp,igrp,udp,nd,或tcp.注意这些标识符tcp,udp,和icmp也同样是关键字,所以必须用反斜杠(\)转义,在C-shell中应该是\\.</p>
	<li>ether broadcast </li>
	<p>
	  如果报文是以太广播报文,则逻辑为真.关键字ether是可选的.</p>
	<li>ip broadcast </li>
	<p>
	  如果报文是IP广播报文,则逻辑为真.Tcpdump检查全0和全1广播约定,并且检查本地的子网掩码.</p>
	<li>ether multicast </li>
	<p>
	  如果报文是以太多目传送报文(multicast),则逻辑为真.关键字ether是可选的.这实际上是`ether[0]&1!=0'的简写.</p>
	<li>ip multicast </li>
	<p>
	  如果报文是IP多目传送报文,则逻辑为真.</p>
	<li>ether proto protocol </li>
	<p>
	  如果报文协议属于以太类型的protocol,则逻辑为真.Protocol可以是数字,也可以是名字,如ip,arp,或rarp.注意这些标识符也是关键字,所以必须用反斜杠(\)转义.[如果是FDDI(例如,`fddiprotocolarp'),协议标识来自802.2逻辑链路控制(LLC)报头,它通常位于FDDI报头的顶层.当根据协议标识过滤报文时,Tcpdump假设所有的FDDI报文含有LLC报头,而且LLC报头用的是SNAP格式.]</p>
	<li>decnet src host </li>
	<p>
	  如果DECNET的源地址是host,则逻辑为真,该主机地址的形式可能是``10.123'',或者是DECNET主机名.[只有配置成运行DECNET的Ultrix系统支持DECNET主机名.]</p>
	<li>decnet dst host </li>
	<p>
	  如果DECNET的目的地址是host,则逻辑为真.</p>
	<li>decnet host host </li>
	<p>
	  如果DECNET的源地址或目的地址是host,则逻辑为真.ip, arp, rarp, decnet是:ether proto p的简写形式,其中p为上述协议的一种.lat, moprc, mopdl 是: ether proto p的简写形式,其中p为上述协议的一种.注意tcpdump目前不知道如何分析这些协议.tcp, udp, icmp 是: ip proto p的简写形式,其中p为上述协议的一种.</p>
	<li>expr relop expr </li>
	<p>
	  如果这个关系成立,则逻辑为真,其中relop是&lt;,&gt;,&lt;=,&gt;=,=,!=之一,expr是数学表达式,由常整数(标准C语法形式),普通的二进制运算符[+,-,*,/,&,|],一个长度运算符,和指定的报文数据访问算符组成.要访问报文内的数据,使用下面的语法:proto [ expr : size ]<br>
	  Proto是ether,fddi,ip,arp,rarp,tcp,udp,oricmp之一,同时也指出了下标操作的协议层.expr给出字节单位的偏移量,该偏移量相对于指定的协议层.Size是可选项,指出感兴趣的字节数;它可以是1,2,4,缺省为1字节.由关键字len给出的长度运算符指明报文的长度.<br>
	  例如,`ether[0]&1!=0'捕捉所有的多目传送报文.表达式`ip[0]&0xf!=5'捕捉所有带可选域的IP报文.表达式`ip[6:2]&0x1fff=0'只捕捉未分片和片偏移为0的数据报.这种检查隐含在tcp和udp下标操作中.例如,tcp[0]一定是TCP报头的第一个字节,而不是其中某个IP片的第一个字节.</p>
	</ul>
	<p>
	  原语可以用下述方法结合使用:</p>
	<p>
	  园括弧括起来的原语和操作符(园括弧在Shell中有专用,所以必须转义).</p>
	<p>
	  取反操作 (`!' or `not').</p>
	<p>
	  连结操作 (`&&' or `and').</p>
	<p>
	  或操作 (`||' or `or').</p>
	<p>
	  取反操作有最高优先级.或操作和连结操作有相同的优先级,运算时从左到右结合.注意连结操作需要显式的and算符,而不是并列放置.</p>
	<p>
	  如果给出标识符,但没给关键字,那么暗指最近使用的关键字.例如,</p>
	<p>
	  not host vs and ace作为not host vs and host ace的简写形式, 不应该和not( host vs or ace )混淆。</p>
	<p>
	  表达式参数可以作为单个参数传给tcpdump,也可以作为复合参数,后者更方便一些.一般说来,如果表达式包含Shell元字符(metacharacter),传递单个括起来的参数要容易一些.复合参数在被解析前用空格联接一起.</p>			

	<h4>tcpdump的输出信息</h4>
	<p>
	  tcpdump命令四种典型的输出信息：</p>

	<h5>数据链路层头信息</h5>
	<p>
	  使用命令：tcpdump -e host host1<br>
	  输出结果：<br>
	  11:15:12.247009 eth0 < 88:0:0:7:2b:26 0:90:27:58:af:1a ip 60: host2.25258 > host1.telnet 0:0(0) ack 22552 win 7890 (DF)<br>
	  分析：“11:15:12”是显示的时间，“247009”是ID号，“eth0 <”表示从网络接口eth0接受该数据包，“88:0:0:7:2b:26”为发送数据主机的MAC地址，“ ip”是表明该数据包是IP类型数据包，“60”是数据包的长度，“ host2.25258 > host1.telnet” 表明该数据包是从主机host2的25258端口发往主机host1的TELNET(23)端口。“ack 22552”表明对序列号是22552的包进行响应。“ win 7890”表明发送窗口的大小是7890。</p>
		  
	<h5>ARP包的TCPDUMP输出信息</h5>
	<p>
	  使用命令：tcpdump arp<br>
	  输出结果：<br>
	  22:32:42.802509 eth0 > arp who-has route tell ice (0:90:27:58:af:1a)<br>
	  分析：“eth0 >”表示从网络接口eth0发送数据包。</p>
	<h5>TCP包的输出信息</h5>
	<p>
	  输出信息：
	  src > dst: flags data-seqno ack window urgent options<br>
	  分析：“src > dst:”表明从源地址到目的地址, flags是TCP包中的标志信息（S是SYN标志，F(FIN)，P(PUSH)，R(RST)，"."(没有标记)）；data-seqno是数据包中的数据的顺序号，ack是下次期望的顺序号，window是接收缓存的窗口大小，urgent表明数据包中是否有紧急指针，Options是选项。</p>
		  
	<h5>UDP包的输出信息</h5>
	<p>
	  输出信息：
	  host.p1 > linux.p2: udp lenth<br>
	  分析：从主机host的p1端口发出的一个udp类型数据包到主机linux的p2端口，包的长度是lenth。</p>
		
	<h3>功能扩展</h3>
	<p>
	  tcpdump还可以结合tcpshow、管道、重定向使用，从而扩展其功能。</p>

	<h3>范例</h3>
	<h4>显示所有进出sundown的报文:</h4>
	<p>
	  tcpdump host sundown</p>
	<h4>显示helios和主机hot,ace之间的报文传送:</h4>
	<p>
	  tcpdump host helios and \( hot or ace \)</p>
	<h4>显示ace和除了helios以外的所有主机的IP报文</h4>
	<p>
	  tcpdump ip host ace and not helios </p>
	<h4>显示本地的主机和Berkeley的主机之间的网络数据</h4>
	<p>
	  tcpdump net ucb-ether </p>	
	<h4>显示所有通过网关snup的ftp报文(注意这个表达式被单引号括起,防止shell解释园括弧)</h4>	
	<p>
	  tcpdump 'gateway snup and (port ftp or ftp-data)' </p>
	<h4>显示既不是来自本地主机,也不是传往本地主机的网络数据(如果你把网关通往某个其他网络,这个做法将不会把数据发往你的本地网络).</h4>
	<p>
	  tcpdump ip and not net localnet </p>		
	<h4>显示每个TCP会话的起始和结束报文(SYN和FIN报文),而且会话方中有一个远程主机.</h4>
	<p>
	  tcpdump 'tcp[13] & 3 != 0 and not src and dst net localnet' </p>
	<h4>显示经过网关snup中大于576字节的IP数据报</h4>
	<p>
	  tcpdump 'gateway snup and ip[2:2] > 576' </p>
	<h4>显示IP广播或多目传送的数据报,这些报文不是通过以太网的广播或多目传送形式传送的</h4>
	<p>
	  tcpdump 'ether[0] & 1 = 0 and ip[16] >= 224' </p>
	<h4>显示所有不是回响请求/应答的ICMP报文(也就是说,不是ping报文)</h4>
	<p>
	  tcpdump 'icmp[0] != 8 and icmp[0] != 0' </p>
	<p>
	  tcpdump的输出格式取决于协议.下面的描述给出大多数格式的简要说明和范例.</p>		
	<h4>链路层报头 (Link Level Headers) </h4>
	<p>
	  如果给出'-e'选项就显示链路层报头.在以太网上,显示报文的源目地址,协议和报文长度.</p>
	<p>
	  在FDDI网络上,'-e'选项导致tcpdump显示出`帧控制(framecontrol)'域,源目地址和报文长度.(`帧控制'域负责解释其余的报文.普通报文(比如说载有IP数据报)是`异步'报文,优先级介于0到7;例如,`async4'.这些被认为载有802.2逻辑链路控制(LLC)报文;如果它们不是ISO数据报或者所谓的SNAP报文,就显示出LLC报头.</p>
	<p>
	  (注意:以下描述中假设你熟悉RFC-1144中说明的SLIP压缩算法.)</p>
	<p>
	  在SLIP链路上,tcpdump显示出方向指示(``I''指inbound,``O''指outbound),报文类型和压缩信息.首先显示的是报文类型.有三种类型ip,utcp和ctcp.对于ip报文不再显示更多的链路信息.对于TCP报文,在类型后面显示连接标识.如果报文是压缩过的,就显示出编码的报头.特殊情形以*S+n和*SA+n的形式显示,这里的n是顺序号(或顺序号及其确认)发生的改变总和.如果不是特殊情形,就显示0或多少个改变.改变由U(urgentpointer),W(window),A(ack),S(sequencenumber)和I(packetID)指明,后跟一个变化量(+nor-n),或另一个值(=n).最后显示报文中的数据总和,以及压缩报头的长度.</p>
	<p>
	  例如,下面一行显示了一个传出的压缩的TCP报文,有一个隐含的连接标识;确认(ack)的变化量是6,顺序号是49,报文ID是6;有三个字节的数据和六个字节的压缩报头:</p>
	<p>
	  O ctcp * A+6 S+49 I+6 3 (6) </p>

	<h4>ARP/RARP 报文 </h4>

	<p>
	  Arp/rarp报文的输出显示请求类型及其参数.输出格式倾向于能够自我解释.这里是一个简单的例子,来自主机rtsg到主机csam的'rlogin'开始部分:</p>
	<p>
	  arp who-has csam tell rtsg </p>
	<p>
	  arp reply csam is-at CSAM </p>

	<p>
	  第一行说明rtsg发出一个arp报文询问internet主机csam的以太网地址.Csam用它的以太地址作应答(这个例子中,以太地址是大写的,internet地址为小写).</p>
	<p>
	  如果 用 tcpdump -n 看上去 要 清楚一些: </p>
	<p>
	  arp who-has 128.3.254.6 tell 128.3.254.68 </p>
	<p>
	  arp reply 128.3.254.6 is-at 02:07:01:00:01:c4 </p>
	<p>
	  如果用tcpdump-e,可以看到实际上第一个报文是广播,第二个报文是点到点的:</p>
	<p>
	  RTSG Broadcast 0806 64: arp who-has csam tell rtsg </p>
	<p>
	  CSAM RTSG 0806 64: arp reply csam is-at CSAM </p>
	<p>
	  这里第一个报文指出以太网源地址是RTSG,目的地址是以太网广播地址,类型域为16进制数0806(类型ETHER_ARP),报文全长64字节.</p>

	<h4>TCP 报文 </h4>
	<p>
	  (注意:以下的描述中假设你熟悉RFC-793中说明的TCP协议,如果你不了解这个协议,无论是本文还是tcpdump都对你用处不大)</p>
	<p>
	  一般说来tcp协议的输出格式是:</p>
	<p>
	  src > dst: flags data-seqno ack window urgent options </p>

	<p>
	  Src和dst是源目IP地址和端口.Flags是S(SYN),F(FIN),P(PUSH)或R(RST)或单独的`.'(无标志),或者是它们的组合.Data-seqno说明了本报文中的数据在流序号中的位置(见下例).Ack是在这条连接上信源机希望下一个接收的字节的流序号(sequencenumber).Window是在这条连接上信源机接收缓冲区的字节大小.Urg表明报文内是`紧急(urgent)'数据.Options是tcp可选报头,用尖括号括起(例如,).</p>
	<p>
	  Src, dst 和 flags肯定存在. 其他域依据报文的tcp报头内容, 只输出有必要的部分. </p>

	<p>
	  下面是从主机rtsgrlogin到主机csam的开始部分.</p>
	<p>rtsg.1023 > csam.login: S 768512:768512(0) win 4096 <br>
	csam.login > rtsg.1023: S 947648:947648(0) ack 768513 win 4096 <br>
	rtsg.1023 > csam.login: P 1:2(1) ack 1 win 4096 <br>
	csam.login > rtsg.1023: . ack 2 win 4096 <br>
	rtsg.1023 > csam.login: P 2:21(19) ack 1 win 4096 <br>
	csam.login > rtsg.1023: P 1:2(1) ack 21 win 4077 <br>
	csam.login > rtsg.1023: P 2:3(1) ack 21 win 4077 urg 1 <br>
	csam.login > rtsg.1023: P 3:4(1) ack 21 win 4077 urg 1 </p>
	<p>
	  第一行是说从rtsg的tcp端口1023向csam的login端口发送报文.S标志表明设置了SYN标志.报文的流序号是768512,没有数据.(这个写成`first:last(nbytes)',意思是`从流序号first到last,不包括last,有nbytes字节的用户数据'.)此时没有捎带确认(piggy-backedack),有效的接收窗口是4096字节,有一个最大段大小(max-segment-size)的选项,请求设置mss为1024字节.</p>
	<p>
	  Csam用类似的形式应答,只是增加了一个对rtsgSYN的捎带确认.然后Rtsg确认csam的SYN.`.'意味着没有设置标志.这个报文不包含数据,因此也就没有数据的流序号.注意这个确认流序号是一个小整数(1).当tcpdump第一次发现一个tcp会话时,它显示报文携带的流序号.在随后收到的报文里,它显示当前报文和最初那个报文的流序号之差.这意味着从第一个报文开始,以后的流序号可以理解成数据流中的相对位移asrelativebytepositionsintheconversation'sdatastream(withthefirstdatabyteeachdirectionbeing`1').`-S'选项能够改变这个特性,直接显示原始的流序号.</p>
	<p>
	  在第六行,rtsg传给csam19个字节的数据(字节2到20).报文中设置了PUSH标志.第七行csam表明它收到了rtsg的数据,字节序号是21,但不包括第21个字节.显然大多数数据在socket的缓冲区内,因为csam的接收窗口收到的数据小于19个字节.同时csam向rtsg发送了一个字节的数据.第八和第九行显示csam发送了两个字节的紧急数据到rtsg.</p>
	<p>
	  如果捕捉区设置的过小,以至于tcpdump不能捕捉到完整的TCP报头,tcpdump会尽可能的翻译已捕获的部分,然后显示``[|tcp]'',表明无法翻译其余部分.如果报头包含一个伪造的选项(onewithalengththat'seithertoosmallorbeyondtheendoftheheader),tcpdump显示``[badopt]''并且不再翻译其他选项部分(因为它不可能判断出从哪儿开始).如果报头长度表明存在选项,但是IP数据报长度不够,不可能真的保存选项,tcpdump就显示``[badhdrlength]''.</p>

	<h4>UDP 报文 </h4>

	<p>
	  UDP格式就象这个rwho报文显示的:</p>
	<p>actinide.who > broadcast.who: udp 84 </p>
	<p>
	  就是说把一个udp数据报从主机actinide的who端口发送到broadcast,Internet广播地址的who端口.报文包含84字节的用户数据.</p>
	<p>
	  某些 UDP 服务 能够 识别出来(从 源目端口号 上), 因而 显示出 更高层的 协议信息. 特别是 域名服务请求(RFC-1034/1035) 和 NFS 的 RPC 调用(RFC-1050). </p>

	<h4>UDP域名服务请求(NameServerRequests)</h4>

	<p>
	  (注意:以下的描述中假设你熟悉RFC-1035说明的域名服务协议.如果你不熟悉这个协议,下面的内容就象是天书.)</p>
	<p>域名服务请求的格式是</p>

	<p>src > dst: id op? flags qtype qclass name (len) </p>
	<p>h2opolo.1538 > helios.domain: 3+ A? ucbvax.berkeley.edu. (37) </p>
	<p>
	  主机h2opolo访问helios上的域名服务,询问和ucbvax.berkeley.edu.关联的地址记录(qtype=A).查询号是`3'.`+'表明设置了递归请求标志.查询长度是37字节,不包括UDP和IP头.查询操作是普通的Query操作,因此op域可以忽略.如果op设置成其他什么东西,它应该显示在`3'和`+'之间.类似的,qclass是普通的C_IN类型,也被忽略了.其他类型的qclass应该在`A'后面显示.</p>
	<p>
	  Tcpdump会检查一些不规则情况,相应的结果作为补充域放在方括号内:如果某个查询包含回答,名字服务或管理机构部分,就把ancount,nscount,或arcount显示成`[na]',`[nn]'或`[nau]',这里的n代表相应的数量.如果在第二和第三字节中,任何一个回答位(AA,RA或rcode)或任何一个`必须为零'的位被置位,就显示`[b2&3=x]',这里的x是报头第二和第三字节的16进制数.</p>

	<h4>UDP名字服务回答</h4>

	<p>名字服务回答的格式是</p>
	<p>src > dst: id op rcode flags a/n/au type class data (len) <br>
	helios.domain > h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273) <br>
	helios.domain > h2opolo.1537: 2 NXDomain* 0/1/0 (97) </p>
	<p>
	  第一个例子里,helios回答了h2opolo发出的标识为3的询问,一共是3个回答记录,3个名字服务记录和7个管理结构记录.第一个回答纪录的类型是A(地址),数据是internet地址128.32.137.3.回答的全长为273字节,不包括UDP和IP报头.作为A记录的class(C_IN)可以忽略op(询问)和rcode(NoError).</p>
	<p>
	  在第二个例子里,helios对标识为2的询问作出域名不存在(NXDomain)的回答,没有回答记录,一个名字服务记录,而且没有管理结构.</p>
	<p>
	  `*'表明设置了权威回答(authoritativeanswer).由于没有回答记录,这里就不显示type,class和data.</p>
	<p>
	  其他标志字符可以显示为`-'(没有设置递归有效(RA))和`|'(设置消息截短(TC)).如果`问题'部分没有有效的内容,就显示`[nq]'.</p>
	<p>
	  注意名字服务的询问和回答一般说来比较大,68字节的snaplen可能无法捕捉到足够的报文内容.如果你的确在研究名字服务的情况,可以使用-s选项增大捕捉缓冲区.`-s128'应该效果不错了.</p>

	<h4>NFS请求和响应</h4>

	<p>
	  SunNFS(网络文件系统)的请求和响应显示格式是:</p>
	<p>src.xid > dst.nfs: len op args <br>
	src.nfs > dst.xid: reply stat len op results <br>
	sushi.6709 > wrl.nfs: 112 readlink fh 21,24/10.73165 <br>
	wrl.nfs > sushi.6709: reply ok 40 readlink "../var" <br>
	sushi.201b > wrl.nfs: <br>
	144 lookup fh 9,74/4096.6878 "xcolors" <br>
	wrl.nfs > sushi.201b: <br>
	reply ok 128 lookup fh 9,74/4134.3150 </p>

	<p>
	  在第一行,主机sushi向wrl发送号码为6709的交易会话(注意源主机后面的数字是交易号,不是端口).这项请求长112字节,不包括UDP和IP报头.在文件句柄(fh)21,24/10.731657119上执行readlink(读取符号连接)操作.(如果运气不错,就象这种情况,文件句柄可以依次翻译成主次设备号,i节点号,和事件号(generationnumber).)Wrl回答`ok'和连接的内容.</p>
	<p>
	  在第三行,sushi请求wrl在目录文件9,74/4096.6878中查找`xcolors'.注意数据的打印格式取决于操作类型.格式应该是可以自我说明的.</p>
	<p>
	  给出-v(verbose)选项可以显示附加信息.例如:</p>
	<p>sushi.1372a > wrl.nfs: </p>
	<p>148 read fh 21,11/12.195 8192 bytes @ 24576 </p>
	<p>wrl.nfs > sushi.1372a: </p>
	<p>reply ok 1472 read REG 100664 ids 417/0 sz 29388 </p>

	<p>
	  (-v同时使它显示IP报头的TTL,ID,和分片域,在这个例子里把它们省略了.)在第一行,sushi请求wrl从文件21,11/12.195的偏移位置24576开始,读取8192字节.Wrl回答`ok';第二行显示的报文是应答的第一个分片,因此只有1472字节(其余数据在后续的分片中传过来,但由于这些分片里没有NFS甚至UDP报头,因此根据所使用的过滤器表达式,有可能不显示).-v选项还会显示一些文件属性(它们作为文件数据的附带部分传回来):文件类型(普通文件``REG''),存取模式(八进制数),uid和gid,以及文件大小.</p>
	<p>
	  如果再给一个-v选项(-vv),还能显示更多的细节.</p>
	<p>
	  注意NFS请求的数据量非常大,除非增加snaplen,否则很多细节无法显示.试一试`-s192'选项.</p>
	<p>
	  NFS应答报文没有明确标明RPC操作.因此tcpdump保留有``近来的''请求记录,根据交易号匹配应答报文.如果应答报文没有相应的请求报文,它就无法分析.</p>

	<h4>KIPAppletalk(UDP上的DDP)</h4>

	<p>
	  AppletalkDDP报文封装在UDP数据报中,解包后按DDP报文转储(也就是说,忽略所有的UDP报头信息).文件/etc/atalk.names用来把appletalk网络和节点号翻译成名字.这个文件的行格式是</p>

	<p>number name <br>
	1.254 ether <br>
	16.1 icsd-net <br>
	1.254.110 ace </p>
	<p>
	  前两行给出了appletalk的网络名称.第三行给出某个主机的名字(主机和网络依据第三组数字区分-网络号一定是两组数字,主机号一定是三组数字.)号码和名字用空白符(空格或tab)隔开./etc/atalk.names文件可以包含空行或注释行(以`#'开始的行).</p>
	<p>
	  Appletalk地址按这个格式显示</p>
	<p>net.host.port </p>
	<p>144.1.209.2 > icsd-net.112.220 </p>
	<p>office.2 > icsd-net.112.220 </p>
	<p>jssmag.149.235 > icsd-net.2 </p>
	<p>
	  (如果不存在/etc/atalk.names,或者里面缺少有效项目,就以数字形式显示地址.)第一个例子里,网络144.1的209节点的NBP(DDP端口2)向网络icsd的112节点的220端口发送数据.第二行和上面一样,只是知道了源节点的全称(`office').第三行是从网络jssmag的149节点的235端口向icsd-net的NBP端口广播(注意广播地址(255)隐含在无主机号的网络名字中-所以在/etc/atalk.names中区分节点名和网络名是个好主意).</p>
	<p>
	  Tcpdump可以翻译NBP(名字联结协议)和ATP(Appletalk交互协议)的报文内容.其他协议只转储协议名称(或号码,如果还没给这个协议注册名称)和报文大小.</p>

	<p>NBP报文的输出格式就象下面的例子:</p>
	<p>icsd-net.112.220 > jssmag.2: nbp-lkup 190: "=:LaserWriter@*" <br>
	jssmag.209.2 > icsd-net.112.220: nbp-reply 190: "RM1140:LaserWriter@*" 250 <br>
	techpit.2 > icsd-net.112.220: nbp-reply 190: "techpit:LaserWriter@*" 186 </p>
	<p>
	  第一行是网络icsd的112主机在网络jssmag上的广播,对名字laserwriter做名字查询请求.名字查询请求的nbp标识号是190.第二行显示的是对这个请求的回答(注意它们有同样的标识号),主机jssmag.209表示在它的250端口注册了一个laserwriter的资源,名字是"RM1140".第三行是这个请求的其他回答,主机techpit的186端口有laserwriter注册的"techpit".</p>
	<p>ATP报文格式如下例所示:</p>

	<p>jssmag.209.165 > helios.132: atp-req 12266<0-7> 0xae030001 <br>
	helios.132 > jssmag.209.165: atp-resp 12266:0 (512) 0xae040000 <br>
	helios.132 > jssmag.209.165: atp-resp 12266:1 (512) 0xae040000 <br>
	helios.132 > jssmag.209.165: atp-resp 12266:2 (512) 0xae040000 <br>
	helios.132 > jssmag.209.165: atp-resp 12266:3 (512) 0xae040000 <br>
	helios.132 > jssmag.209.165: atp-resp 12266:4 (512) 0xae040000 <br>
	helios.132 > jssmag.209.165: atp-resp 12266:5 (512) 0xae040000 <br>
	helios.132 > jssmag.209.165: atp-resp 12266:6 (512) 0xae040000 <br>
	helios.132 > jssmag.209.165: atp-resp*12266:7 (512) 0xae040000 <br>
	jssmag.209.165 > helios.132: atp-req 12266<3,5> 0xae030001 <br>
	helios.132 > jssmag.209.165: atp-resp 12266:3 (512) 0xae040000 <br>
	helios.132 > jssmag.209.165: atp-resp 12266:5 (512) 0xae040000 <br>
	jssmag.209.165 > helios.132: atp-rel 12266<0-7> 0xae030001 <br>
	jssmag.209.133 > helios.132: atp-req* 12267<0-7> 0xae030002 </p>

	<p>
	  Jssmag.209向主机helios发起12266号交易,请求8个报文(`<0-7>').行尾的十六进制数是请求中`userdata'域的值.<br>
	  Helios用8个512字节的报文应答.跟在交易号后面的`:digit'给筹</p>

	<p>实例：<br>
	#tcpdump -i eth0 -X src host 10.1.2.1</p>
	
	<h3>总结</h3>
	<h3>参考资料</h3>
	<ul>
	  <li><a href="http://www.tcpdump.org/tcpdump_man.html">man手册</li>
	  <li><a href="http://www.tcpdump.org/">tcpdump官方网站帮助文档</a></li>
	</ul>

  </div>
</div>

<br clear="all">

<script src="/js/footer.cn.js" language="javascript" type="text/javascript"></script>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
_uacct = "UA-468239-3";
urchinTracker();
</script>

</body>

</html>
